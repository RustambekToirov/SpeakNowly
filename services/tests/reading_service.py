from fastapi import HTTPException, status
from typing import List, Dict, Any
from tortoise.transactions import in_transaction
from datetime import datetime, timedelta, timezone
import json
import random

from models.tests import (
    ReadingPassage, ReadingQuestion, ReadingVariant,
    Reading, ReadingAnswer,
    Constants, TestTypeEnum
)
from services.analyses import ReadingAnalyseService
from services.chatgpt import ChatGPTReadingIntegration
from utils import get_user_actual_test_price
from models import TokenTransaction, TransactionType, User

DIFFICULTY_ORDER = ["easy", "medium", "hard"]

async def get_user_reading_level(user_id: int) -> str:
    """
    Determines the difficulty level for a new test based on the user's history.
    """
    # Get the last 3 completed tests of the user
    recent_sessions = await Reading.filter(
        user_id=user_id,
        status=Constants.ReadingStatus.COMPLETED.value
    ).order_by("-end_time").limit(3)

    if not recent_sessions or len(recent_sessions) < 3:
        return "easy" # Beginner or not enough data

    # Calculate the average score for the last 3 tests
    avg_score = sum([float(s.score or 0) for s in recent_sessions]) / len(recent_sessions)

    # Get the current level (from the last test)
    last_level = getattr(recent_sessions[0], "level", None) or "easy"
    if last_level not in DIFFICULTY_ORDER:
        last_level = "easy"

    # Logic for increasing/decreasing level
    if avg_score >= 32 and last_level == "easy":
        return "medium"
    elif avg_score >= 32 and last_level == "medium":
        return "hard"
    elif avg_score < 25 and last_level == "medium":
        return "easy"
    elif avg_score < 25 and last_level == "hard":
        return "medium"
    else:
        return last_level


class ReadingService:
    """
    Service for managing reading tests and sessions.
    """

    @staticmethod
    async def start_session(user_id: int, t: dict) -> Dict[str, Any]:
        """
        Start a new reading session for a user with a test generated by ChatGPT.
        """
        # Validate user exists
        user = await User.get_or_none(id=user_id)
        if not user:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("user_not_found", "User not found")
            )

        # Determine test difficulty based on user history
        level = await get_user_reading_level(user_id)

        # Check if user has enough tokens
        price = await get_user_actual_test_price(user, TestTypeEnum.READING_ENG.value)
        if user.tokens < price:
            raise HTTPException(
                status_code=status.HTTP_402_PAYMENT_REQUIRED,
                detail=t.get("insufficient_tokens", "Insufficient tokens")
            )

        # Get passages from database
        passage_ids = [p.id for p in await ReadingPassage.filter(id__gte=20, id__lte=102)]
        if len(passage_ids) < 3:
            raise HTTPException(
                status_code=400,
                detail=t.get("not_enough_passages", "Not enough passages in DB")
            )

        # Select random passage set
        start_idx = random.randint(0, len(passage_ids) - 3)
        selected_ids = passage_ids[start_idx:start_idx+3]
        passages = await ReadingPassage.filter(id__in=selected_ids).prefetch_related("questions__variants")

        # Create session and process payment
        async with in_transaction():
            # Deduct tokens
            user.tokens -= price
            await user.save()
            await TokenTransaction.create(
                user_id=user.id,
                transaction_type=TransactionType.TEST_READING.value,
                amount=price,
                balance_after_transaction=user.tokens,
                description=t.get("transaction_description", f"Reading test (-{price} tokens)"),
            )
            
            # Create session
            session = await Reading.create(
                user_id=user.id,
                start_time=datetime.now(timezone.utc),
                end_time=None,
                status=Constants.ReadingStatus.STARTED.value,
                score=0.0,
                level=level,
            )
            
            # Associate passages with session
            for passage in passages:
                await session.passages.add(passage)
                
            # Create blank answers
            await ReadingService._create_blank_answers(session)
            
        return await ReadingService._format_session_data(session)

    @staticmethod
    async def _create_blank_answers(session: Reading):
        """
        Create blank answers for all questions in the reading session.
        """
        passages = await session.passages.all()
        passage_ids = [p.id for p in passages]
        if not passage_ids:
            return

        questions = await ReadingQuestion.filter(passage_id__in=passage_ids)

        answers = [
            ReadingAnswer(
                user_id=session.user_id,
                reading_id=session.id,
                question_id=question.id,
                status=ReadingAnswer.NOT_ANSWERED,
            )
            for question in questions
        ]
        await ReadingAnswer.bulk_create(answers)

    @staticmethod
    async def _format_session_data(session: Reading) -> Dict[str, Any]:
        """
        Format reading session data for response.
        """
        passages = await session.passages.all().prefetch_related("questions__variants")
        return {
            "id": session.id,
            "start_time": session.start_time,
            "end_time": session.end_time,
            "passages": [
                {
                    "id": passage.id,
                    "title": passage.title,
                    "skills": passage.skills,
                    "questions_count": await passage.questions.all().count(),
                }
                for passage in passages
            ],
        }

    @staticmethod
    async def submit_answers(
        session_id: int, user_id: int, passage_id: int, answers: List[Dict[str, Any]], t: dict
    ) -> int:
        """
        Save answers for a reading session passage. No analysis here!
        Only checks session status.
        """
        # Validate session exists
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )

        # Check if already completed or cancelled
        if session.status in [Constants.ReadingStatus.COMPLETED.value, Constants.ReadingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_already_completed_or_cancelled", "Session already completed or cancelled")
            )

        # Save answers
        async with in_transaction():
            for ans in answers:
                await ReadingAnswer.update_or_create(
                    defaults={
                        "text": ans.get("answer", "").strip(),
                        "status": ReadingAnswer.ANSWERED,
                    },
                    user_id=user_id,
                    reading_id=session_id,
                    question_id=ans["question_id"],
                )
                
        return len(answers)

    @staticmethod
    async def finish_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Finish reading session and get analysis.
        """
        # Validate session exists
        session = await Reading.get_or_none(id=session_id, user_id=user_id).prefetch_related("passages")
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )

        # Check if already completed
        if session.status in [Constants.ReadingStatus.COMPLETED.value, Constants.ReadingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_already_completed_or_cancelled", "Session already completed or cancelled")
            )

        # Mark as completed and analyze
        session.status = Constants.ReadingStatus.COMPLETED.value
        session.end_time = datetime.now(timezone.utc)
        await session.save()

        # Generate analysis
        await ReadingAnalyseService.analyse(session_id, user_id)
        
        return await ReadingService._full_analysis_response(session, user_id)

    @staticmethod
    async def cancel_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Cancel a reading session.
        """
        # Validate session exists
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )

        # Check if can be cancelled
        if session.status in [Constants.ReadingStatus.COMPLETED.value, Constants.ReadingStatus.CANCELLED.value]:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_already_completed_or_cancelled", "Session already completed or cancelled")
            )

        # Mark as cancelled
        session.status = Constants.ReadingStatus.CANCELLED.value
        await session.save(update_fields=["status"])
        
        return {"message": t.get("session_cancelled", "Session cancelled")}

    @staticmethod
    async def restart_session(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Restart a reading session.
        """
        # Validate session exists
        session = await Reading.get_or_none(id=session_id, user_id=user_id)
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )

        # Check if can be restarted
        if session.status == Constants.ReadingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_already_completed", "Session already completed")
            )

        # Reset session
        session.status = Constants.ReadingStatus.PENDING.value
        if session.end_time is not None:
            session.end_time = session.end_time + timedelta(minutes=20)
        else:
            session.end_time = datetime.now(timezone.utc) + timedelta(minutes=20)
        await session.save()
        
        # Delete answers
        await ReadingAnswer.filter(reading_id=session_id, user_id=user_id).delete()
        
        return {"message": t.get("session_restarted", "Session restarted")}

    @staticmethod
    async def get_analysis(session_id: int, user_id: int, t: dict) -> Dict[str, Any]:
        """
        Get analysis for a completed session.
        """
        # Validate session exists
        session = await Reading.get_or_none(id=session_id, user_id=user_id).prefetch_related("passages")
        if not session:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=t.get("session_not_found", "Session not found")
            )
            
        # Check if completed
        if session.status != Constants.ReadingStatus.COMPLETED.value:
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail=t.get("session_not_completed", "Session not completed")
            )
            
        return await ReadingService._full_analysis_response(session, user_id)

    @staticmethod
    async def _full_analysis_response(session, user_id) -> Dict[str, Any]:
        """
        Generate detailed analysis response.
        """
        # Load passages and questions
        passages = await session.passages.all().prefetch_related("questions__variants")
        passage_ids = [p.id for p in passages]

        # Load existing analyses and answers
        analyses = await ReadingAnalyseService.get_all_analyses(session.id, user_id)
        analyses_by_pid = {a.passage_id: a for a in analyses}
        answers = await ReadingAnswer.filter(
            user_id=user_id,
            reading_id=session.id,
            question_id__in=[q.id for p in passages for q in p.questions]
        ).select_related("question")
        answers_by_qid = {a.question_id: a for a in answers}

        # Format passage results
        passage_results = []
        total_correct = total_questions = 0

        for passage in passages:
            analyse = analyses_by_pid.get(passage.id)
            if not analyse:
                # Skip passages without submitted answers
                continue

            # Format questions and answers
            question_results = []
            for question in passage.questions:
                ans = answers_by_qid.get(question.id)
                # Default values
                user_ans = ans.text if ans else ""
                is_corr = bool(ans.is_correct) if ans else False

                if ans and ans.correct_answer not in (None, "default", ""):
                    corr_ans = ans.correct_answer
                elif question.type == "MULTIPLE_CHOICE":
                    correct_var = next((v for v in question.variants if v.is_correct), None)
                    corr_ans = correct_var.text if correct_var else ""
                else:
                    corr_ans = ""

                expl = ans.explanation if ans and ans.explanation is not None else ""
                question_results.append({
                    "id": question.id,
                    "text": question.text,
                    "type": question.type,
                    "answers": [
                        {"id": v.id, "text": v.text, "is_correct": v.is_correct}
                        for v in question.variants
                    ],
                    "user_answer": user_ans,
                    "correct_answer": corr_ans,
                    "explanation": expl,
                    "is_correct": is_corr,
                })
                total_questions += 1
                if is_corr:
                    total_correct += 1

            # Add passage data
            passage_results.append({
                "id": passage.id,
                "title": passage.title,
                "text": passage.text,
                "skills": passage.skills,
                "questions": question_results,
                "overall_score": float(analyse.overall_score),
                "timing": analyse.duration.total_seconds() if analyse.duration else 0,
            })

        # Compute overall IELTS band (use IELTS mapping, not percent)
        def calculate_ielts_band(correct):
            mapping = {
                range(39, 41): 9.0,
                range(37, 39): 8.5,
                range(35, 37): 8.0,
                range(32, 35): 7.5,
                range(30, 32): 7.0,
                range(26, 30): 6.5,
                range(23, 26): 6.0,
                range(18, 23): 5.5,
                range(16, 18): 5.0,
                range(13, 16): 4.5,
                range(10, 13): 4.0,
                range(7, 10): 3.5,
                range(5, 7): 3.0,
                range(3, 5): 2.5,
                range(1, 3): 2.0,
                range(0, 1): 0.0,
            }
            for score_range, band in mapping.items():
                if total_correct in score_range:
                    return band
            return 0.0

        band = calculate_ielts_band(total_correct)

        # Calculate elapsed time
        elapsed = (session.end_time - session.start_time).total_seconds() / 60

        return {
            "score": round(band, 2),
            "correct": f"{total_correct}/{total_questions}",
            "time": round(elapsed, 2),
            "start_time": session.start_time,
            "end_time": session.end_time,
            "passages": passage_results,
        }
